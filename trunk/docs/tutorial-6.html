<html>
<head>
  <title>Gosu - Tutorial</title>
  <link rel="stylesheet" type="text/css" href="gosu.css" />
  <script type="text/javascript" language="Javascript" src="tutorial.js"></script>
</head>

<body class="rightSide" onLoad="showLang('cpp')">

<h1>Animations</h1>

<a href="javaScript:showLang('cpp')">show C++ version</a> - <a href="javaScript:showLang('ruby')">show Ruby version</a>

<h2>Needed Headers</h2>
<div class="cpp"><p><pre>
#include &lt;Gosu/AutoLink.hpp&gt;
#include &lt;Gosu/AutoLinkMain.hpp&gt;
#include &lt;Gosu/Bitmap.hpp&gt;
#include &lt;Gosu/Color.hpp&gt;
#include &lt;Gosu/Directories.hpp&gt;
#include &lt;Gosu/Font.hpp&gt;
#include &lt;Gosu/Image.hpp&gt;
#include &lt;Gosu/Input.hpp&gt;
#include &lt;Gosu/IO.hpp&gt;
#include &lt;Gosu/Math.hpp&gt;
#include &lt;Gosu/Text.hpp&gt;
#include &lt;Gosu/Timing.hpp&gt;
#include &lt;Gosu/Window.hpp&gt;
#include &lt;boost/lexical_cast.hpp&gt;
#include &lt;boost/scoped_ptr.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
</pre></p></div>

<h2>Z-Ordering Done Right</h2>

<div class="cpp"><p>
  Even before we introduce animated objects, let's take a look at a technique that will make it much easier for us to add new elements.
</p>
<p>
  Using an enum for the Z order is very convenient. Because enum values can be converted into ints implicitly, you can just write down all the game's layers from bottom to top in an enum and pass them as the z argument. This is the enum used by the tutorial game (even though only two of the layers are already present):
</p>
<p><pre>
enum ZOrder
{
    zBackground,
    zStars,
    zPlayer,
    zUI
};
</pre></p></div>

<div class="ruby"><p>
  In the previous lessons, we have just used magic numbers as the Z argument. Of course, this is a pain to maintain, so let's define some constants for that purpose:
</p>
<p><pre>
module ZOrder
  Background, Stars, Player, UI = *0..3
end
</pre></p></div>

<p>
  Accordingly, the player and background are now drawn that way:
</p>

<div class="cpp"><p><pre>
class Player
{
    ...
    void draw() const
    {
        image->drawRot(posX, posY, <strong>zPlayer</strong>, angle);
    }
    ...
};

class GameWindow : public Gosu::Window
{
   ...
   void draw()
   {
        player.draw();
        backgroundImage->draw(0, 0, <strong>zBackground</strong>);
   }
   ...
};
</pre></p></div>
<div class="ruby"><pre><p>
class Player
  ...
  def draw
    @image.draw_rot(@x, @y, ZOrder::Player, @angle)
  end
  ...
end
  
class GameWindow &lt; Gosu::Window
  ...
  def draw
    @player.draw
    @background_image.draw(0, 0, ZOrder::Background)
  end
  ...
end
</p></pre></div>

<div class="cpp"><h2>The Animation typedef</h2>
<p>
  What is an animation? A sequence of images. So a naive Animation type might look like this:
</p>
<p><pre>
typedef std::vector&lt;Gosu::Image&gt; Animation;
</pre></p>
<p>
  However, std::vector expects a type that can be copied, which is not possible for Gosu::Images. Even if they could, it would be a very expensive operation. The easiest solution is to use boost::shared_ptr:
</p>
<p><pre>
typedef std::vector&lt;boost::shared_ptr&lt;Gosu::Image&gt; &gt; Animation;
</pre></p>
<p>
  And this is exactly what we'll use.
</p>
</div>

<div class="ruby"><h2>Arrays as Animations</h2>
<p>
  What is an animation? A sequence of images - so we'll use Ruby's built in Arrays to store them.
</p>
</div>

<p>
  For a real game, there is no way around writing some classes that fit the game's individual needs, but we'll get away with this simple solution for now.
</p>

<h2>The Star class</h2>
<p>
  It's time to introduce the stars which are the central object of this lesson. Stars appear out of nowhere at a random place on the screen and live their animated lives until the player collects them. The definition of the Star class is rather simple:
</p>
<div class="cpp"><p><pre>
class Star
{
    Animation animation;
    Gosu::Color color;
    double posX, posY;

public:
    explicit Star(const Animation&amp; anim);

    double x() const { return posX; }
    double y() const { return posY; }

    void draw() const;
};
</pre></p></div>
<div class="ruby"><p><pre>
class Star
  attr_reader :x, :y
  
  def initialize(animation); ... end
  
  def draw; ... end
end
</pre></p></div>
<p>
  The constructor copies the given animation, randomizes the star's colour and places it at a random position. Let's look at the code for that:
</p>

<div class="cpp"><p><pre>
    explicit Star(const Animation&amp; anim)
    : animation(anim)
    {
        color.setAlpha(255);
        double red = Gosu::random(40, 255);
        color.setRed(static_cast&lt;Gosu::Color::Channel&gt;(red));
        double green = Gosu::random(40, 255);
        color.setGreen(static_cast&lt;Gosu::Color::Channel&gt;(green));
        double blue = Gosu::random(40, 255);
        color.setBlue(static_cast&lt;Gosu::Color::Channel&gt;(blue));

        posX = Gosu::random(0, 640);
        posY = Gosu::random(0, 480);
    }
</pre></p>
<p>
  The complicated looking lines randomize the colour. It always has the alpha channel set to the maximum, i.e. all stars are visible. However, the three colour channels are set to a value from 40 to 255 - which is done in two steps. First, a random double value is generated using Gosu::random(min, max) from Gosu/Math.hpp. Then it is cast into the type used for colour channels (boost::uint8_t) to suppress some warnings. It's actually really simple code :)
</p></div>

<div class="ruby"><p><pre>
  def initialize(animation)
    @animation = animation
    @color = Gosu::Color.new(0xff000000)
    @color.red = rand(255 - 40) + 40
    @color.green = rand(255 - 40) + 40
    @color.blue = rand(255 - 40) + 40
    @x = rand * 640
    @y = rand * 480
  end
</pre></p></div>

<p>
  Now for the actual animations. Hold your breath, this game uses the cheapest technique ever for animations:
</p>
<div class="cpp"><p><pre>
    void draw() const
    {
        Gosu::Image&amp; image = 
            *animation[Gosu::milliseconds() / 100 % animation.size()];

        image.draw(posX - image.width() / 2.0, posY - image.height() / 2.0,
            zStars, 1, 1, color, Gosu::amAdditive);
    }
</pre></p></div>
<div class="ruby"><p><pre>
  def draw
    img = @animation[Gosu::milliseconds / 100 % @animation.size];
    img.draw(@x - img.width / 2.0, @y - img.height / 2.0,
        ZOrder::Stars, 1, 1, @color, :additive)
  end
</pre></p></div>
<p>
  To show a different frame of the stars' animation every 100 milliseconds, the time returned by Gosu::milliseconds() is divided by 100 and then modulo-ed down to the number of frames. Finally, a reference to this frame's image is created. Again, it's up to you to make up better techniques that suit your project's needs.
</p>
<p>
  Anyway, this image is then additively drawn, centered at the star's position and modulated by the colour we generated in the constructor.
</p>

<h2>Collecting Stars</h2>
<p>
  Of course, there are some changes to be made to the player and the window. Let's start with the player, which gets a new member function:
</p>
<div class="cpp"><p><pre>
class Player
{
    ...
    void collectStars(std::list&lt;Star&gt;&amp; stars, unsigned&amp; score)
    {
        std::list&lt;Star&gt;::iterator cur = stars.begin();
        while (cur != stars.end())
        {
            double distX = posX - cur->x();
            double distY = posY - cur->y();
            double dist = std::sqrt(distX * distX + distY * distY);

            if (dist &lt; 35)
            {
                cur = stars.erase(cur);
                score += 10;
            }
            else
            {
                ++cur;
            }
        }
    }
    ...
};
</pre></p></div>
<div class="ruby"><p><pre>
  def collect_stars(stars)
    stars.reject! do |star|
      dist_x = @x - star.x
      dist_y = @y - star.y
      dist = Math.sqrt(dist_x * dist_x + dist_y * dist_y)
      if dist &lt; 35 then
        yield 10
        @beep.play
        true
      else
        false
      end
    end
  end
</pre></p></div>
<p>
  This is just standard code to remove all the stars from a given container that are close enough to the player. Luckily, standard containers and Pythagoras' theorem are beyond the scope of this tutorial.
</p>
<div class="ruby"><p>
  What's the "yield 10" for? We need some way to increment the game's score (which we'll introduce later) from inside collect_stars. As Ruby features no reference parameters, collect_stars can be given a block that will be called every time collect_stars wants to increase the score, with the amount as the first argument.
</p></div>

<h2>What's Missing?</h2>
<p>
  Now it's time to modify the GameWindow class. There are three things desperately missing right now: Loading the animation, creating the stars container and calling the player's new member function to collect stars. Also, displaying the current score sounds like a good feature to have.
</p>

<h2>Preparations</h2>
<p>
  For some of these changes we need new member variables: The star animation, the list of stars, a variable to hold the current score and a bitmap font to display it. When I added the new variables, I decided to split GameWindow's member variables into media resources (top) and game state (bottom):
</p>

<div class="ruby"><p><pre>
  def initialize
    super(640, 480, false, 20)
    self.caption = "Gosu Tutorial Game"
    
    @font = Gosu::Font.new(self, Gosu::default_font_name, 20)
    @background_image = Gosu::Image.new(self, "media/Space.png", true)
    @star_anim = Gosu::Image::load_tiles(self, "media/Star.png", 25, 25, false)
    
    @player = Player.new(self)
    @player.warp(320, 240)
    @stars = Array.new
    @score = 0
  end
</pre></p>
<p>
  The first of the two major changes is the initialization of the bitmap font. Like an image, it needs a Window reference to be created. It then takes a font name and a font height (in pixels). Because font names are not portable, Gosu provides the default_font_name() function which returns the name of a a simple sans serif font.
</p>
<p>
  The second addition is the call to Image::load_tiles. This is a convenience function that loads a whole array of images from an image file. In our case, we want to split the image loaded from Star.png into 25x25px tiles with no hard borders (false) and store those images in @star_anim. You can find out more about this handy function in the reference - it's useful for loading animations and tilesets.
</p></div>

<div class="cpp"><p><pre>
class GameWindow : public Gosu::Window
{
    boost::scoped_ptr&lt;Gosu::Image&gt; backgroundImage;
    Animation starAnim;
    Gosu::Font font;

    Player player;
    std::list&lt;Star&gt; stars;
    unsigned score;

public:
    ...
</pre></p>
<p>
  Of course the new variables have to be initialized, and this is where it gets more interesting:
</p>
<p><pre>
    GameWindow()
    : Window(640, 480, false, 20),
        font(graphics(), Gosu::defaultFontName(), 20),
        player(graphics())
    {
        setCaption(L"Gosu Tutorial Game");

        Gosu::Bitmap bitmap;

        Gosu::Buffer backgroundFile;
        Gosu::loadFile(backgroundFile, Gosu::sharedResourcePrefix() + L"media/Space.png");
        Gosu::loadFromPNG(bitmap, backgroundFile.frontReader());
        backgroundImage.reset(new Gosu::Image(graphics(), bitmap));

        Gosu::Buffer starFile;
        Gosu::loadFile(starFile, Gosu::sharedResourcePrefix() + L"media/Star.png");
        Gosu::loadFromPNG(bitmap, starFile.frontReader());
        Gosu::imagesFromTiledBitmap(graphics(), bitmap, 25, 25, false, starAnim);

        player.warp(320, 240);
        score = 0;
    }
</pre></p>
<p>
  The first of the two major changes is the initialization of the bitmap font. Like an image, it needs a Graphics reference to be created. It then takes a font name and a font height (in pixels). Because font names are not portable, Gosu provides the defaultFontName() function which returns the name of a a simple sans serif font.
</p>
<p>
  The second addition is the call to imagesFromTiledBitmap. This is a convenience function that loads a whole array of images from a bitmap and stores them in an arbitrary STL container of boost::shared_ptr&lt;Gosu::Image&gt;. In our case, we want to split the bitmap loaded from Star.png into 25x25px tiles with no hard borders (false) and store those images in starAnim. You can find out more about this handy function in the reference - it's useful for loading animations and tilesets.
</p></div>

<h2>Stars Coming and Going</h2>
<p>
  Now that everything's prepared, we can let the stars appear and be collected by the player. It's just a matter of a few new lines in GameWindow's update function:
</p>
<div class="cpp"><p><pre>
    void update()
    {
        ...
        player.move();
        player.collectStars(stars, score);

        if (std::rand() % 25 == 0 &amp;&amp; stars.size() &lt; 25)
            stars.push_back(Star(starAnim));
    }
</pre></p></div>
<div class="ruby"><p><pre>
  def update
    ...
    @player.move
    @player.collect_stars(@stars) { |gain| @score += gain }
    
    if rand(100) &lt; 4 and @stars.size &lt; 25 then
      @stars.push(Star.new(@star_anim))
    end
  end
</pre></p></div>

<h2>Watching the Stars</h2>
<p>
  Finally, all the things we added need to be drawn. Again, thanks to our preparation, things are rather simple:
</p>
<div class="cpp"><p><pre>
    void draw()
    {
        player.draw();
        backgroundImage->draw(0, 0, zBackground);

        for (std::list&lt;Star&gt;::const_iterator i = stars.begin();
            i != stars.end(); ++i)
        {
            i->draw();
        }

        font.draw(L"Score: " + boost::lexical_cast&lt;std::wstring&gt;(score),
            10, 10, zUI, 1, 1, Gosu::Colors::yellow);
    }
</pre></p>
<p>
  The new for loop draws all the stars - it could hardly be more straightforward.
</p>
<p>
  The last line for this lesson is a bit more complicated. First, the score is converted into an std::wstring using boost::lexical_cast (look up its reference if you've never heard of it, or believe me it does the right thing). This string is then drawn above everything else via Z ordering and so its top left corner is at (10, 10). The two 1's are the scaling factors - we pass 1 (the default value), so the font is drawn as high as we created it in the constructor (20 pixels). The last argument is just the colour used to draw the text. (By default, it would be white.) Again, the list of all arguments can be found in the reference.
</p></div>

<div class="ruby"><p><pre>
  def draw
    @font.draw("Score: #{@score}", 10, 10, ZOrder::UI, 1.0, 1.0, 0xffffff00)
    @background_image.draw(0, 0, ZOrder::Background)
    @player.draw
    @stars.each { |star| star.draw }
  end
</pre></p>
<p>
  The only interesting line here is the first one. The string containing the score is drawn above everything else via Z ordering and so its top left corner is at (10, 10). The two 1's are the scaling factors - we pass 1 (the default value), so the font is drawn as high as we created it in the constructor (20 pixels). The last argument is just the colour used to draw the text. (By default, it would be white.) Again, the list of all arguments can be found in the reference.
</p>
</div>

</body>
</html>